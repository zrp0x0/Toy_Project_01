# Day 002


### 비관적 락 (Pessimistic Lock)의 명과 암
- 장점
    - 확실하다
    - 결과가 절대 틀릴 일이 절대 없음
    - 모든 트랜잭션을 한 줄 서기로 만들어버림
    - 작업이 끝날 때까지 아무도 들어오지 말라고 DB 차원에서 막아버리니 충돌 자체가 발생하지 않음

- 단점
    - 느리다, 너무 느리가 (Performance Issue)
    - 만약 한 명단 처리 시간이 0.1초 걸린다면?
        - 락 없을 때: 100명을 거의 동시에 0.1~0.2초만에 끝남(물론 재고는 틀림)
        - 비관적 락: 1번째 사람(0.1초)... 100번째 사람(10초 대기)
    - 티켓팅 상황이라면? 수만 명이 몰리는데, 뒷 사람들은 타임아웃으로 하얀 화면만 보이게 됨

- 더 무서운 단점: 데드락
    - 서로가 서로의 자물쇠를 기다리는 상황이 발생할 수 있음
    - User A: 공연 A를 잠그고, 공연 B를 예매하려고 기다림
    - User B: 공연 B를 잠그고, 공연 A를 예매하려고 기다림
    - 결과: 둘 당 영원히 멈춤

- 다른 선택지는?
    - 충돌이 그렇게 자주 나겠어? 일단 들어가고 문제 생기며 그 때 해결하자라는 긍정적인 방식
    - **낙관적 락(Optimistic Lock)**
    - 이 방식은 자물쇠를 걸지 않음. 대신 버전(Version)이라는 딱지를 붙여서 관리함
        - 장점: 락을 안거니깐 엄청 빠름 (DB 커넥션을 점유하지 않음)
        - 단점: 충돌이 나면 재시도 로직을 우리가 직접 짜야함 (좀 귀찮음)


### 낙관적 락(Optimistic Lock)의 명과 암
- 기본 동작 흐름
    - 철수 V1이네?
    - 영희 V1이네?
    - 철수 V1을 V2로 바꾸면서 저장 -> 성공 (DB V2)
    - 영희 V1읖 V2로 바꾸면서 저장 -> 실패 (DB는 이미 V2임)
        - 재시도 로직 구현 필요
        - Facade 패턴


### Facade 패턴
- 낙관적 락은 실패하면 ObjectOptimisticLockingFailureException이라는 에러를 뱉음
- 에러 났어요로 끝내면 안되고 다시 시도해!! 라고 성공할 때까지 돌려야함


### 낙관적 락 vs 비관적 락
- 일단 현재 코드로 실험 결과
* 비관적락: 1921ms
* 낙관적락: 3203ms

- DB 업데이트 비용보다 재시도하면서 대기하는 시간과 계속 쿼리를 날리는 오버헤드가 훨씬 컸던 탓
- 특히 재시도 텀을 50ms로 잡아놨기 때문에 충돌이 날 때마다 0.05초 씩 딜레이가 누적되어 전체 시간이 길어짐

- 결론: 무조건 좋은 기술은 없음
    - 비관적락 | 낙관적락
    - 충돌이 잦은 경우(수강신청, 선착순 이벤트) | 충돌이 거의 없는 경우(일반 게시글 수정)
    - 데이터 정합성을 완벽 보장, 충돌 많을 때 성능 우위 | 락을 안 걸어서 가벼움, 충돌이 없을 때 압도적
    - 데드락 위험이 있음, 기본적으로 무거움 | 재시도 로직 구현 필요, 충돌이 많으면 느려짐
    - 화장실 문 잠그고 쓰기 | 들어가보고 사람 있으면 다시 오기


### Phase 3 제안: Redis의 도입
- DB 락으로도 해결은 되지만 DB는 소중한 자원이라서 락을 걸고 있으면 다른 서비스(로그인, 게시판 등)까지 전체적으로 느려질 위험이 있음
- DB가 아닌 메모리(Redis)로 옮겨서 처리함
