# Day 002


### 비관적 락 (Pessimistic Lock)의 명과 암
- 장점
    - 확실하다
    - 결과가 절대 틀릴 일이 절대 없음
    - 모든 트랜잭션을 한 줄 서기로 만들어버림
    - 작업이 끝날 때까지 아무도 들어오지 말라고 DB 차원에서 막아버리니 충돌 자체가 발생하지 않음

- 단점
    - 느리다, 너무 느리가 (Performance Issue)
    - 만약 한 명단 처리 시간이 0.1초 걸린다면?
        - 락 없을 때: 100명을 거의 동시에 0.1~0.2초만에 끝남(물론 재고는 틀림)
        - 비관적 락: 1번째 사람(0.1초)... 100번째 사람(10초 대기)
    - 티켓팅 상황이라면? 수만 명이 몰리는데, 뒷 사람들은 타임아웃으로 하얀 화면만 보이게 됨

- 더 무서운 단점: 데드락
    - 서로가 서로의 자물쇠를 기다리는 상황이 발생할 수 있음
    - User A: 공연 A를 잠그고, 공연 B를 예매하려고 기다림
    - User B: 공연 B를 잠그고, 공연 A를 예매하려고 기다림
    - 결과: 둘 당 영원히 멈춤

- 다른 선택지는?
    - 충돌이 그렇게 자주 나겠어? 일단 들어가고 문제 생기며 그 때 해결하자라는 긍정적인 방식
    - **낙관적 락(Optimistic Lock)**
    - 이 방식은 자물쇠를 걸지 않음. 대신 버전(Version)이라는 딱지를 붙여서 관리함
        - 장점: 락을 안거니깐 엄청 빠름 (DB 커넥션을 점유하지 않음)
        - 단점: 충돌이 나면 재시도 로직을 우리가 직접 짜야함 (좀 귀찮음)


### 낙관적 락(Optimistic Lock)의 명과 암
- 기본 동작 흐름
    - 철수 V1이네?
    - 영희 V1이네?
    - 철수 V1을 V2로 바꾸면서 저장 -> 성공 (DB V2)
    - 영희 V1읖 V2로 바꾸면서 저장 -> 실패 (DB는 이미 V2임)
        - 재시도 로직 구현 필요
        - Facade 패턴


### Facade 패턴
- 낙관적 락은 실패하면 ObjectOptimisticLockingFailureException이라는 에러를 뱉음
- 에러 났어요로 끝내면 안되고 다시 시도해!! 라고 성공할 때까지 돌려야함


### 낙관적 락 vs 비관적 락
- 일단 현재 코드로 실험 결과
* 비관적락: 1921ms
* 낙관적락: 3203ms

- DB 업데이트 비용보다 재시도하면서 대기하는 시간과 계속 쿼리를 날리는 오버헤드가 훨씬 컸던 탓
- 특히 재시도 텀을 50ms로 잡아놨기 때문에 충돌이 날 때마다 0.05초 씩 딜레이가 누적되어 전체 시간이 길어짐

- 결론: 무조건 좋은 기술은 없음
    - 비관적락 | 낙관적락
    - 충돌이 잦은 경우(수강신청, 선착순 이벤트) | 충돌이 거의 없는 경우(일반 게시글 수정)
    - 데이터 정합성을 완벽 보장, 충돌 많을 때 성능 우위 | 락을 안 걸어서 가벼움, 충돌이 없을 때 압도적
    - 데드락 위험이 있음, 기본적으로 무거움 | 재시도 로직 구현 필요, 충돌이 많으면 느려짐
    - 화장실 문 잠그고 쓰기 | 들어가보고 사람 있으면 다시 오기


### Phase 3 제안: Redis의 도입
- DB 락으로도 해결은 되지만 DB는 소중한 자원이라서 락을 걸고 있으면 다른 서비스(로그인, 게시판 등)까지 전체적으로 느려질 위험이 있음
- DB가 아닌 메모리(Redis)로 옮겨서 처리함


### Redis vs 비관적락 vs 낙관적락
* 비관적락: 1921ms
* 낙관적락: 3203ms
* redis 락: 3158ms

- 일단 Redis가 왜 졌을까에 대한 고찰
    - 네트워크 오버헤드 (가장 큰 원인일듯)
        - 비관적락 Java 앱과 DB가 커넥션을 이미 맺고 있으면 쿼리만 보내면 DB 내부에서 고속으로 줄을 세움
        - Redis 락: 락을 걸때마다 Java <-> Docker Network <-> Redis 사이를 왔다 갔다해야함
            - 락 획득 요청, 응답, 락 해제 요청, 응답 = 최소 4번의 통신
            - 이 비용이 엄청 큼

    - Redisson의 복잡성
        - 락 획득을 위해 내부적으로 Pub/Sub을 사용하고, 타임아웃을 체크하는 등 비관적락보다 로직이 훨씬 무거움

    - 낙관적락 vs Redis
        - 낙관적락은 재시도 / Redis는 통신 비용


### Redis를 사용하는 이유
- 지금은 Spring Boot 서버 1대 + DB 1대라서 비관적 락이 짱임
- 하지만 실제 티켓팅 환경(대용량 트래픽)에서는 이야기가 달라짐
    - 1. DB는 비싸고 소중함
        - 비관적 락을 사용하면 트랜잭션 내내 DB 커낵션을 물고 있음
        - 티켓팅 때문에 DB가 락 잡느라 바빠지면 로그인, 게시판 조회도 안되는 전체 장애가 발생할 수도 있음
            - 이건 커넥션 풀에 대한 개념이 필요함
            - 10개의 풀이 다 락을 잡아버리면 전체 장애 발생
        - Redis를 쓰면 줄 세우기 역할을 Redis에게 외주를 주는 셈이라 DB는 결과 저장만 하면 되서 부하가 줄어듦

    - 2. 서버가 여러 대라면
        - 서버가 10대로 늘어나면 DB 락은 여전히 유효하지만, DB의 병목 현상이 심해짐
        - Redis는 초당 수만 건의 락 처리가 가능해 확장성이 뛰어남


### 앞으로 할 일 
- 일단 Redis락을 기반으로 사용함
- 이제 Reservation 도메인을 작성해서 누가 예매했는지 기록을 

- 그냥 갑자기 떠올라서 적는건데
    - 이게 들어온 순서 자체를 보장해주지 않네
    - 그니깐 수량이 100개여도 101번째 사람이 먹을 수도 있다는거


### Reservation 기반 완료
- 이제 Redis Cache를 사용해서 조회 성능을 높여보자!!!


### 조회 성능을 높여보자!!
- 일단 그전에 그냥 한 마디만 하자면 나한테
    - 두려워했더? 마주하려고 하지 않았던 것들 
    - 하나씩 꾸준히 천천히 격파해나가고 있는 모습임을 항상 기억해라
    - 끝까지 버텨라 내가 너를 승리하게 할 것이다


### 자 이제 조회 성능을 높여보자!!
- 구현할 전략
    - 표준적인 캐싱 전략인 Look Aside (Cache Aside)패턴 사용
    - 조회 요청: 사용자가 공연 목록 (findAll())을 요청
    - 캐시 확인: 먼저 Redis를 보자
        - 있으면(Hit): DB 안 가고 바로 반환
        - 없으면(Miss): DB에서 조회하고 Redis에 저장해둔 뒤 반환 (처음 한 번만 느림)

- Redis 설정 (직렬화)
    - Redis는 텍스트나 바이너리 데이터만 저장할 수 있음
    - List<PerformanceResponse>를 저장하려면 JSON 문자열로 변환하는 설정이 필요함

- 주의할 점:
    - 공연 목록을 저장해두었는데 관리자가 새 공연을 등록하면 어떻게 될까?
    - 캐시는 과거 목록을 가지고 있음 (데이터 불일치)
    - 새 데이터가 추가되거나 변경되면 기존 캐시를 지워라!! 라는 설정이 필요함


### 조회 성능 테스트
* 1차 조회 시간 (DB): 89ms - Redis 저장 + DB 조회가 합쳐진 시간
* 2차 조회 시간 (Redis): 59ms - 여기부터 Redis
* 3차 조회 시간 (Redis): 3ms
* 3차 조회 시간 (Redis): 4ms

- 이유:
> JSON 변환기(Jackson)의 학습 시간 (가장 큰 이유로 추측 중)
    - 상황: Redis는 데이터를 JSON 문자열로 저장
    - Java는 이걸 다시 객체로 바꿔야함 (역질렬화)
    - 2차 조회 시 Json 변환기가 PerformanceResponse라는 클래스를 난생 처음 만남
        - 필드가 뭐지? 생성자는 무지? 분석(Reflection)하고 준비하느라 시간이 걸림

    - 3차 조회: 기억(캐싱)하고 있음 속도가 비약적으로 빨라짐

> 커넥션 풀 활성화
    - Spring과 Redis 사이에는 미리 연결 통로를 만들어둠
    - 2차 조회 때는 만들어는 놨지만 막상 데이터를 실어 나르는 건 처름이라 통로를 열고 스트림을 연결하는 미세한 초기 비용이 발생함
    - 3차 조회: 이미 데이터가 한 번 지나갔던 따끈따끈하게 열린 통로를 그대로 재사용함(TCP 연결 재사용)

> JIT 컴파일러
    - Java는 코드를 실행하면서 자주 쓰는 코드네다 싶으면 기계ㅓ(Native Code)로 번역해서 최적화해버림


### 잠깐 나중에 읽어볼 것
```text
결론부터 말씀드리면, 비관적 락(Pessimistic Lock)이 반드시 데이터베이스 '전체'를 락(Lock) 거는 것은 아닙니다. 하지만 잘못 사용하면 시스템 전체 성능에 심각한 영향을 줄 수 있습니다.

질문하신 두 가지 포인트에 대해 나누어 설명해 드릴게요.

1. 비관적 락은 전체 자원을 잠그는가?
아닙니다. 일반적으로 현대적인 관계형 데이터베이스(MySQL의 InnoDB 등)에서 비관적 락(SELECT ... FOR UPDATE)을 사용하면 **"행(Row) 단위"**로 락이 걸립니다.

정상적인 경우 (Row-level Lock): ID가 1번인 상품에 락을 걸면, 1번 상품 데이터(Row)만 잠깁니다. ID가 2번인 상품을 조회하거나 수정하는 트랜잭션은 아무런 영향을 받지 않고 정상적으로 동작합니다.

위험한 경우 (Table-level Lock으로 확대): 만약 락을 걸 때 사용하는 조건 컬럼에 인덱스(Index)가 없다면, 데이터베이스는 어떤 행을 잠가야 할지 정확히 알 수 없어 테이블 전체(Table Full Scan)를 잠가버릴 수 있습니다. 이때는 말씀하신 것처럼 해당 테이블을 사용하는 모든 작업이 멈출 수 있습니다.

2. 왜 로그인, 게시글 작성 같은 다른 기능도 느려지는가?
"나는 '상품 구매' 기능에만 락을 걸었는데, 왜 전혀 상관없는 '로그인'이나 '게시글 쓰기'가 느려지지?"라는 의문이 드실 수 있습니다. 여기에는 크게 두 가지 이유가 있습니다.

① DB 커넥션 풀(Connection Pool) 고갈 [가장 큰 원인]
웹 애플리케이션(스프링 부트 등)은 DB와 통신하기 위해 **미리 정해진 개수의 연결 통로(Connection Pool)**를 만들어 둡니다 (예: 10개).

비관적 락을 사용하면 트랜잭션이 끝날 때까지 락을 해제하지 않고 대기합니다.

이때 락을 획득하려고 대기하는 스레드들은 DB 연결(Connection)을 붙잡고 놓아주지 않습니다.

구매 요청이 몰려서 10개의 DB 연결이 모두 '구매 대기 중' 상태가 되면, 남은 연결이 0개가 됩니다.

이때 누군가 로그인을 시도하면, 로그인 쿼리를 날릴 DB 연결 자체가 없어서 대기하게 됩니다.

결국 상품 구매와 상관없는 로그인, 게시글 작성 등 모든 기능이 "응답 없음" 상태에 빠지게 됩니다.

② 같은 테이블을 건드리는 경우 (Lock Contention)
전혀 다른 기능 같아 보여도 내부적으로 같은 테이블의 같은 행을 건드린다면 영향을 받습니다.

상황:

비관적 락: 포인트 차감을 위해 Member 테이블의 '철수' 행에 락을 걸었습니다.

로그인: 로그인을 하면 Member 테이블의 '최근 접속일(last_login_at)'을 업데이트하려고 합니다.

결과:

로그인 기능은 포인트 기능이 끝날 때까지 '철수' 행을 수정할 수 없어서 멈춰버립니다.

요약 및 해결책
범위: 비관적 락은 기본적으로 행(Row) 단위로 걸리지만, 인덱스가 없으면 테이블 단위로 커질 수 있으므로 인덱스 설정이 필수적입니다.

성능 저하 원인: 락이 길어지면 **DB 커넥션(연결)**을 점유하는 시간이 길어지고, 이로 인해 풀(Pool)이 고갈되어 전체 서버 장애로 이어질 수 있습니다.

권장 사항:

비관적 락은 충돌이 매우 잦아 데이터 정합성이 깨질 확률이 높은 경우에만 제한적으로 사용하세요.

트랜잭션(락을 유지하는 시간)을 최대한 짧게 가져가야 합니다.

성능 이슈가 우려된다면 **낙관적 락(Optimistic Lock)**이나 Redis(분산 락) 등을 고려해 볼 수 있습니다.
```

* @CacheEvict(value = "performances", allEntries = true)
* allEntries = true: performances라는 이름 공간 안에 있는 모든 키를 싹 비웁니다.

### 예약 취소
- 예약 확인: 취소하려는 예약이 존재하는지, 이미 취소된 건 아닌지 확인
- 재고 복구: 해당 공연의 재고를 취소한 수량만큼 다시 늘려줌
- 상태 변경: 예약 상태를 CANCELED로 바꿉

