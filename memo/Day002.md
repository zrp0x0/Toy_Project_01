# Day 002


### 비관적 락 (Pessimistic Lock)의 명과 암
- 장점
    - 확실하다
    - 결과가 절대 틀릴 일이 절대 없음
    - 모든 트랜잭션을 한 줄 서기로 만들어버림
    - 작업이 끝날 때까지 아무도 들어오지 말라고 DB 차원에서 막아버리니 충돌 자체가 발생하지 않음

- 단점
    - 느리다, 너무 느리가 (Performance Issue)
    - 만약 한 명단 처리 시간이 0.1초 걸린다면?
        - 락 없을 때: 100명을 거의 동시에 0.1~0.2초만에 끝남(물론 재고는 틀림)
        - 비관적 락: 1번째 사람(0.1초)... 100번째 사람(10초 대기)
    - 티켓팅 상황이라면? 수만 명이 몰리는데, 뒷 사람들은 타임아웃으로 하얀 화면만 보이게 됨

- 더 무서운 단점: 데드락
    - 서로가 서로의 자물쇠를 기다리는 상황이 발생할 수 있음
    - User A: 공연 A를 잠그고, 공연 B를 예매하려고 기다림
    - User B: 공연 B를 잠그고, 공연 A를 예매하려고 기다림
    - 결과: 둘 당 영원히 멈춤

- 다른 선택지는?
    - 충돌이 그렇게 자주 나겠어? 일단 들어가고 문제 생기며 그 때 해결하자라는 긍정적인 방식
    - **낙관적 락(Optimistic Lock)**
    - 이 방식은 자물쇠를 걸지 않음. 대신 버전(Version)이라는 딱지를 붙여서 관리함
        - 장점: 락을 안거니깐 엄청 빠름 (DB 커넥션을 점유하지 않음)
        - 단점: 충돌이 나면 재시도 로직을 우리가 직접 짜야함 (좀 귀찮음)


### 낙관적 락(Optimistic Lock)의 명과 암
- 기본 동작 흐름
    - 철수 V1이네?
    - 영희 V1이네?
    - 철수 V1을 V2로 바꾸면서 저장 -> 성공 (DB V2)
    - 영희 V1읖 V2로 바꾸면서 저장 -> 실패 (DB는 이미 V2임)
        - 재시도 로직 구현 필요
        - Facade 패턴


### Facade 패턴
- 낙관적 락은 실패하면 ObjectOptimisticLockingFailureException이라는 에러를 뱉음
- 에러 났어요로 끝내면 안되고 다시 시도해!! 라고 성공할 때까지 돌려야함


### 낙관적 락 vs 비관적 락
- 일단 현재 코드로 실험 결과
* 비관적락: 1921ms
* 낙관적락: 3203ms

- DB 업데이트 비용보다 재시도하면서 대기하는 시간과 계속 쿼리를 날리는 오버헤드가 훨씬 컸던 탓
- 특히 재시도 텀을 50ms로 잡아놨기 때문에 충돌이 날 때마다 0.05초 씩 딜레이가 누적되어 전체 시간이 길어짐

- 결론: 무조건 좋은 기술은 없음
    - 비관적락 | 낙관적락
    - 충돌이 잦은 경우(수강신청, 선착순 이벤트) | 충돌이 거의 없는 경우(일반 게시글 수정)
    - 데이터 정합성을 완벽 보장, 충돌 많을 때 성능 우위 | 락을 안 걸어서 가벼움, 충돌이 없을 때 압도적
    - 데드락 위험이 있음, 기본적으로 무거움 | 재시도 로직 구현 필요, 충돌이 많으면 느려짐
    - 화장실 문 잠그고 쓰기 | 들어가보고 사람 있으면 다시 오기


### Phase 3 제안: Redis의 도입
- DB 락으로도 해결은 되지만 DB는 소중한 자원이라서 락을 걸고 있으면 다른 서비스(로그인, 게시판 등)까지 전체적으로 느려질 위험이 있음
- DB가 아닌 메모리(Redis)로 옮겨서 처리함


### Redis vs 비관적락 vs 낙관적락
* 비관적락: 1921ms
* 낙관적락: 3203ms
* redis 락: 3158ms

- 일단 Redis가 왜 졌을까에 대한 고찰
    - 네트워크 오버헤드 (가장 큰 원인일듯)
        - 비관적락 Java 앱과 DB가 커넥션을 이미 맺고 있으면 쿼리만 보내면 DB 내부에서 고속으로 줄을 세움
        - Redis 락: 락을 걸때마다 Java <-> Docker Network <-> Redis 사이를 왔다 갔다해야함
            - 락 획득 요청, 응답, 락 해제 요청, 응답 = 최소 4번의 통신
            - 이 비용이 엄청 큼

    - Redisson의 복잡성
        - 락 획득을 위해 내부적으로 Pub/Sub을 사용하고, 타임아웃을 체크하는 등 비관적락보다 로직이 훨씬 무거움

    - 낙관적락 vs Redis
        - 낙관적락은 재시도 / Redis는 통신 비용


### Redis를 사용하는 이유
- 지금은 Spring Boot 서버 1대 + DB 1대라서 비관적 락이 짱임
- 하지만 실제 티켓팅 환경(대용량 트래픽)에서는 이야기가 달라짐
    - 1. DB는 비싸고 소중함
        - 비관적 락을 사용하면 트랜잭션 내내 DB 커낵션을 물고 있음
        - 티켓팅 때문에 DB가 락 잡느라 바빠지면 로그인, 게시판 조회도 안되는 전체 장애가 발생할 수도 있음
            - 이건 커넥션 풀에 대한 개념이 필요함
            - 10개의 풀이 다 락을 잡아버리면 전체 장애 발생
        - Redis를 쓰면 줄 세우기 역할을 Redis에게 외주를 주는 셈이라 DB는 결과 저장만 하면 되서 부하가 줄어듦

    - 2. 서버가 여러 대라면
        - 서버가 10대로 늘어나면 DB 락은 여전히 유효하지만, DB의 병목 현상이 심해짐
        - Redis는 초당 수만 건의 락 처리가 가능해 확장성이 뛰어남


### 앞으로 할 일 
- 일단 Redis락을 기반으로 사용함
- 이제 Reservation 도메인을 작성해서 누가 예매했는지 기록을 남기자